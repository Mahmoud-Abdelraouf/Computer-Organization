/**
 * @file PriorityResolver_tbAutoRotation.v .
 * @brief Testbench for the Priority Resolver module with automatic rotation mode.
 */

 /**
 * @brief Testbench for the Priority Resolver module.
 * @details Simulates various scenarios to verify the functionality of the Priority Resolver module.
 */
 module PriorityResolver_tbAutoRotation();
 // Inputs
    reg freezing;
    reg [7:0] IRR_reg;
    reg [7:0] ISR_reg;
    reg [2:0] resetedISR_index;
    reg [7:0] OCW2;
    reg INT_requestAck = 0;


    // Outputs
    wire [2:0] serviced_interrupt_index;
    wire [2:0] zeroLevelPriorityBit;
    wire INT_request;


    // Instantiate the InterruptRequestRegister module
    PriorityResolver pr_inst(
        .freezing(freezing),
        .IRR_reg(IRR_reg),
        .ISR_reg(ISR_reg),
        .resetedISR_index(resetedISR_index),
        .OCW2(OCW2),
        .INT_requestAck,
        .serviced_interrupt_index(serviced_interrupt_index),
        .zeroLevelPriorityBit(zeroLevelPriorityBit),
        .INT_request(INT_request)
    );
    
    integer testCaseNo;
    integer i;
    integer j;
    integer k;
    // Stimulus
    initial begin
      /*
       * Automatic rotation tests.
       * OCW2 will have the value of 000xxxxx or 100xxxxx or 101xxxxx.
       * Zero priority level index must equal resetedISR_index + 1 all the time.
       * Check All the expected outputs to be as expected.
       */
       #20 testCaseNo = 0;
        //->Test case 0: 
        // -Inputs: ISR empty, IRR changes randomly, resetedISR_index is the test variable, will be all the possible values, 
        // OCW2 indicates for AUTO_ROTATION_MODE (Test variable), INT_requestAck is zero.
        // -Expected Outputs: serviced_interrupt_index is x,
        // (important) zeroLevelPriorityBit is resetedISR_index + 1 all the time, INT_request is changes with IRR_reg.
        // -The test flow: check all the values of OCW2 to give all the expected outputs.
        ISR_reg = 8'b0;
        IRR_reg = 8'b0;
        resetedISR_index = 1'bx;
        INT_requestAck = 1'b0;
        freezing = 1'b0;
        for(i = 0; i < 32; i = i + 1) begin
            OCW2 = {3'b000, i[4:0]};
            IRR_reg = $urandom;
            #10;
        end
        for(i = 0; i < 32; i = i + 1) begin
            OCW2 = {3'b100, i[4:0]};
            IRR_reg = $urandom;
            #10;
        end        
        for(i = 0; i < 32; i = i + 1) begin
            OCW2 = {3'b101, i[4:0]};
            IRR_reg = $urandom;
            #10;
        end
        //reset values
        ISR_reg = 8'bx;
        IRR_reg = 8'bx;
        resetedISR_index = 1'bx;
        INT_requestAck = 1'bx;
        OCW2 = 1'bx;
        freezing = 1'bx;

        $stop';
    end
    /*
    * When an INT_request arrived, INT_requestAck must be inverted.
    */
    always @(posedge INT_request) begin
        INT_requestAck <= ~INT_requestAck;
    end
    
 endmodule    